## Overload operator and Conversion
使用运算符重载可以使我们的程序更易于编写和阅读。举个例子，因为在Sales_item类中定义了输入，输出和加法运算符，所以可以通过下述形式输出两个Sales_item的和:
```C++
std::cout << item1 + item2; // 输出两个Sales_item的和
```

### 基本概念

重载的运算符具有特殊名字：关键字operator和其后定义的运算符符号共同组成。重载运算符也包含返回类型、参数列表和函数体。<br>
重载运算符函数的参数数量与该运算符作用的运算符对象数量一样多。一元运算符有一个参数，二元运算符有两个。对于二元运算符来说，左侧运算对象传递给第一个参数，右侧运算对象传递给第二个参数。重载运算符不能还有默认实参<br>
运算符函数是成员函数，则它的第一个运算对象绑定到隐式的this指针上，因此，成员运算符函数(显示)参数数量比运算符的运算对象总数少一个。<br>
对于运算符函数来说，它或者是类的成员，或者至少含有一个类类型的成员:
```C++
// 错误: 不能定义int 重定义内置运算符
int operator+(int,int);
```
我们可以重置大多数（不是全部）运算符:
<table>
</table>

有四个符号(+,-,*,&)既是一元运算符也是二元运算符，所有这些运算符都能被重载，从参数的数量我们可以推断到底哪种运算符。

##### 直接调用一个重载的运算符函数
我们将运算符作用于类型正确的实参，从而以这种间接方式“调用”重载的运算符函数。然而，我们也能像调用普通函数一样直接调用运算符函数，先指定函数名字，然后传入数量正确、类型适当的实参:
```C++
data1 + data2;
operator+(data1, data2);
```

##### 某些运算符不应该被重载
逻辑与(&),逻辑或(|)和逗号(,)的运算符对象求值顺序无法保留下来。除此之外，&& 和||运算符重载版本也无法保留内置运算符的短路求值属性。不重载逗号运算符和取地址运算符。

##### 使用与内置类型一致的含义
重载运算符的返回类型通常情况下应该与其内置版本的返回类型兼容:逻辑运算符的关系运算符应该返回bool，算数运算符应该返回一个类类型的值，赋值运算符和复合运算符则应该返回左侧运算对象的一个引用

##### 赋值和复合运算符
赋值运算符的行为与复合版本类似:赋值之后，左侧运算符对象和右侧运算对象的值相等，并且运算符应该返回它左侧运算对象的一个引用，如果类含有算术运算符或位运算符，则最好也提供对应的符合赋值运算符。+=运算符的行为显然应该与其内置版本一致，先执行+，再执行=。

##### 选择作为成员或者非成员
当我们定义重载的运算时，必须首先决定是将其声明为类的成员函数还是声明为一个普通的非成员函数。在某些时候我们别无选择，因为有的运算符必须作为成员；另一些情况下，运算符作为普通函数比作为成员更好：
- 赋值(=)、下标（[]）、调用(())和成员箭头(->)运算符必须是成员
- 复合运算符一般来说是成员，但并非必须
- 递增、递减和解引用运算符，通常应该是成员
- 具有对称性的运算符可能转换任意一端的运算对象，例如算术、相等性、关系和位运算符，因此它们通常应该是普通的非成员函数

我们希望能在含有混合类型的表达式中使用对称性运算符。加法是对称的。如果我们想提供含有类对象的混合类型表达式，则运算符必须定义成非成员函数。当我们把运算符定义成成员 函数时，左侧运算对象必须是运算符所属类的一个对象:
```C++
string s = "world";
string t = s+ "!";      // 正确
string u = "hi" + s;    // 如果+是string的成员，产生错误
```
如果operator+是string的成员，则上面第一个加法等价s.operator+("!")。同样的，"hi"+s等价"hi".operator+(s)。显然"hi"的类型是const char *,内置类型根本没有成员函数。<br>
string 将+定义成普通非成员函数， "hi" + s等价于operator+("hi",s)。和任何其他函数调用一样，每个实参都能被转换成形参类型。唯一的要求是至少一个运算对象是类类型，并且两个运算对象都能准确无误转换成string。

### 输入输出运算符
IO标准库分别使用>>和<< 执行时输入和输出操作。这两个运算符来说，IO库定义了其读写内置类型的版本，而类则需要定义适合其对象的新版本以支持IO操作。

#### 重载输出运算符<<
输出运算符的第一个形参是一个非常量ostream对象的引用。之所以ostream是非常量，因为向流写入内容会改变其状态。第二个形参一般来说是一个常量的引用，该常量是我们想要打印的类类型。第二个形参是引用的原因是我们希望避免复制实参。为了与其他输出运算符保持一致，operator<< 一般要返回它的ostream形参。

##### Sales_data输出运算符
我们按照如下形式编写Sales_data的输出运算符:
```C++
std::ostream & operator<<(std::ostream &os, const Sales_data &entry)
{
    os << "bookNo: " << entry.bookNo << ", units_sold: " << entry.units_sold << ", revenue: " << entry.revenue;
    return os;
}
```
除了名字之外，这个函数与之前print函数完全一样。完成输出后，运算符返回刚刚使用的ostream的引用。

##### 输入输出运算符必须非成员函数
与iostream标准库兼容的输入输出运算符必须是普通非成员函数，而不能是类的成员函数。否则，它们的左侧运算对象将是我们的类的一个对象:
```C++
Sales_data data;
data << cout;   // 如果operator<<是Sales_data的成员
```
假设输入输出运算符是某个类的成员，则它们也必须是istream或ostream的成员。然而，这两个类属于标准库，并且我们无法给标准库中的类添加任何成员。因此，如果我们希望为类自定义IO运算符，则必须将其定义成非成员函数。当然，IO运算符通常需要读写类的非公有数据成员，所以IO运算符一般被声明为友元。

#### 重载输入运算符>>
通常情况下，输入运算符的第一个形参是运算符将要读取的流引用，第二个形参是将要读入到对象的引用。该运算符通常会返回某个给定流的引用。第二个形参必须是个非常量。 

##### Sales_data的输入运算符
我们将按照如下形式编写Sales_data的输入运算符:
```C++
std::istream & operator>>(std::istream &is, Sales_data &rhm)
{
    double price = 0;
    is >> rhm.bookNo >> rhm.units_sold >> price;
    if (is)
    {
        rhm.revenue = rhm.units_sold * price;
    }
    else 
    {
        rhm = Sales_data(); // 输入失败：对象被赋予默认状态
    }
    return is;
}
```
除了if语句之外，这个定义与之前read函数完全一样。if语句检查读取操作是否成功，如果发生了IO错误，则运算符将给定的对象重置为空Sales_data,这样可以确保对象处于正确的状态。

##### 输入时的错误
如果读取操作失败，则price的值将是未定义的。因此，在使用price前我们需要首先检查输入流的合法性，然后才能执行计算并将结果存入revenue。如果发生了错误，我们无须在意到底是哪部分输入失败，只要将一个新的默认初始化的Sales_data对象赋予item从而将其重置为空Sales_data就可以了。执行这样的赋值后，item的bookNo成员将是一个空string,revenue和units_sold。

##### 标识错误
一些输入运算符需要做更多数据验证工作。例如，我们的输入运算符可能需要检查bookNo是否符合规范的格式。在这样的例子中，即使从技术上来看IO是成功的，输入运算符也应该设置流的条件状态以标识出失败信息。通常情况下，输入运算符只设置failbit。
