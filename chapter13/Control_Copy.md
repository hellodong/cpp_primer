## Control Copy

[TOC]

定义一个类时，我们显示或者隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

### 拷贝、赋值与销毁
我们将以最基本的操作----拷贝构造函数、拷贝赋值运算符和析构函数作为开始。然后介绍移动操作(新标准所引入的操作)。

#### 拷贝构造函数
如果一个构造函数第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
```C++
class Foo{
    public:
        Foo();              // 默认构造函数
        Foo(const Foo&);    // 拷贝构造函数
};
```
拷贝构造函数的第一个参数必须是一个引用类型。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常不应该是explicit。

##### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。<br>
对于某些类来说,**合成拷贝构造函数**用来阻止我们拷贝该类类型的对象。一般情况,合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

##### 拷贝初始化
```C++
string dots(10,'.');        // 直接初始化
string s(dots);             // 直接初始化
string s2 = dots;           // 拷贝初始化
string null_book = "9-999-99999-9"; //拷贝初始化
string nines = string(100,'9');     //拷贝初始化
```
我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。<br>
拷贝初始化通常使用拷贝构造函数来完成。但是如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。现在，拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。<br>
拷贝初始化不仅在我们用=定义变量时会发生，下列情况也会发生:
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。例如,初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。

##### 参数和返回值
在函数调用过程中，其有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。

#### 拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

##### 重载赋值运算符
重载运算符本质上函数，其名字由operator关键字后接表示要定义的运算符的符号组成。赋值运算符：operator=。其由返回类型和一个参数列表。<br>
拷贝赋值运算符接受一个与其苏哦在类相同类型的参数:
```C++
class Foo{
    public:
    Foo &operator=(const Foo&);
};
```
赋值运算符通常返回一个指向其左侧运算对象的引用。另外，标准库通常要求保存在容器中的类型要具有运算符，其返回值是左侧运算对象的引用。

##### 合成拷贝赋值运算符
与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**。对于某些类，合成拷贝构造函数运算符用来禁止该类型对象的赋值。如果并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

#### 析构函数
析构函数执行与构造函数相反的操作:构造函数初始化对象的非static成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员。<br>
析构函数是类的一个成员函数，名字由波浪号接类名组成。它没有返回值，也不接受参数:
```C++
class Foo{
    public:
        ~Foo();
};
```
对于一个给定类，只有一个析构函数。
##### 析构函数完成什么工作
在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序销毁。在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。<br>
析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。<br>
无论何时一个对象被销毁，就会自动调用其析构函数：
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器(标准库容器或者数组)被销毁时，其元素也被销毁
- 动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 临时对象，创建它的完整表达式结束时被销毁

##### 合成析构函数
当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。<br>
下面的代码片段等价于Sales_data的合成析构函数:
```C++
class Sales_data{
    public:
        ~Sales_data(){}
};
```
在(空)析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被调用，它将释放bookNo成员所用的内存。析构函数体自身并不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的。

#### 三五法则
如前所述，有三个基本可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。而且，在C++11标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。<br>
C++语言并不要求我们定义所有这些操作:可以只定义其中一个 或两个，而不必定义所有。但是这些操作通常应该被看做一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是少见的。

##### 需要析构函数的类也需要拷贝和赋值操作
当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个**析构函数**。如果这个类需要析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。<br>
用HasPtr类作为例子，这个类在构造函数中分配动态内存。合成析构函数不会delete一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。
```C++
class HasPtr{
    public:
        HasPtr(const std::string &s=std::string()):ps(new std::string(s)), i(0) {}
        ~HasPtr(){
            delete ps;
        }
};
```
构造函数中分配的内存将在HasPtr对象销毁时被释放。但是，我们引入了个严重的错误！这个版本的类使用了合成的拷贝构造函数和拷贝赋值运算符。这些函数简单拷贝指针成员，意味着多个HasPtr对象可能指向相同的内存：
```C++
HasPtr f(HasPtr hp)     //传值参数，所以被拷贝
{
    HasPtr ret = hp;    // 拷贝给定的HasPtr
    /* process hp */
    return ret;         // ret和hp被销毁
}
```
当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构函数会delete ret和hp的指针成员。此代码会导致此指针被delete两次，这显然是一个错误。

##### 需要拷贝操作的类也需要赋值操作，反之亦然
某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。如果一个类需要拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。然而，无论是否需要拷贝构造函数还是拷贝赋值运算符都不必然以为着也需要析构函数。

#### 使用=default
可以通过将拷贝控制成员函数定义为 **=default** 来显示要求编译器生成合成的版本：
```C++
class Sales_data{
    public:
        Sales_data() = default;
        Sales_data(const Sales_data &) = default;
        Sales_data &operator=(const Sales_data &);
        ~Sales_data() = default;
};

Sales_data& Sales_data::operator=(const Sales_data &rhs) = default;
```
当我们在类内用=default修饰成员的申明时，合成的函数将隐式地声明为内联的。如果我们不希望合成的成员是内联函数，应该只对成员的类外定义使用=default,就像对拷贝赋值运算符所做的那样。

- 我们只能对具有合成版本的成员函数使用=default

#### 阻止拷贝
大多数类应该定义拷贝构造函数和拷贝赋值运算符，但对某些类来说，这些操作没有合理的意义。此时，定义类时必须采用某种机制阻止拷贝或赋值。

##### 定义删除的函数
在C++11标准下，我们可以通过将拷贝构造函数和拷贝赋值运算符定义为删除的函数来阻止拷贝。删除的函数是这样一种函数:我们虽然声明了他们，但不能以任何方式使用它们。在函数的参数列表后面加上=deleted来指出我们希望将它定义为删除的:
```C++
struct NoCopy{
    NoCopy() = default;     // 使用合成的默认构造函数
    NoCopy(const NoCopy &) = delete;     //阻止拷贝
    NoCopy& operator=(const NoCopy &) = delete; //阻止赋值
    ~NoCopy() = default;        //使用合成的析构函数
};
```
=delete 通知编译器，我们不希望定义这些成员。与=default不同，=delete必须出现在函数第一次声明的时候，这个差异与这些声明的含义在逻辑上是吻合的。一个默认的成员只影响为这个成员而生成的代码，因此=default直到编译器生成代码时才需要。另一方面，编译器需要直到一个函数是删除的，以便禁止试图使用它的操作。与=default的另一个不同之处：我们可以对任何函数指定=delete(我们指定对编译器可以合成的默认构造函数或拷贝控制成员使用=default)。

##### 析构函数不能是删除的成员
我们不能删除析构函数。如果析构函数被删除，就无法销毁此类型的对象了。对于一个删除了析构函数的类型，编译器不允许定义该类型的变量或创建该类型的临时对象。而且如果一个类有某个成员的类型删除了析构函数，我们也不能定义该类的变量或临时对象。因为如果一个成员的析构函数是删除的，则该成员无法被销毁。一个成员无法被销毁，对象整体也就无法被销毁了。<br>
对于删除了析构函数的类型，虽然我们不能定义这种类型的变量或成员，但可以动态分配这种类型的对象。但是，不能释放这些对象:
```C++
struct NoDtor{
    NoDtor() = default; //使用合成默认构造函数
    ~NoDtor() = delete; //我们不能销毁NoDtor类型的对象
};

NoDtor nd;  // 错误:NoDtor的析构函数是删除的
NoDtor *p = new NoDtor();   //正确: 但我们不能delete p
delete p;   // 错误: NoDtor的析构函数是删除的
```

##### 合成的拷贝控制成员可能是删除的
对某些类来说，编译器将这些合成的成员定义为删除的函数:
- 如果类的某个成员的析构函数是删除的或不可访问的(private),则类的合成析构函数被定义为删除的
- 如果类的某个成员的拷贝构造函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。如果类的某个成员的析构函数是删除的或不可访问的，则类合成的拷贝构造函数也被定义为删除的
- 如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是类有一个const的或引用成员，则类的合成拷贝赋值运算符被定义为删除的
- 如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是类有一个const成员，它没有类内初始化器且未显示定义默认构造函数，则该类的默认构造函数被定义为删除的
  
本质上，这些规则含义是:如果一个类有数据成员不能默认构造、拷贝、赋值或销毁，则对应成员函数被定义为删除的。

##### private拷贝控制 
在C++11发布之前，类是通过将其拷贝构造函数和拷贝运算符声明为private来阻止拷贝:
```C++
class PrivateCopy{
    PrivateCopy(const PrivateCopy &);
    PrivateCopy &operator=(const PirvateCopy &);
    public:
    PrivateCopy() = default;
    ~PrivateCopy();
};
```
由于拷贝构造函数和拷贝运算符是private的，用户代码将不能拷贝这个类型的对象。但是友元和成员函数仍旧可以拷贝对象，只声明不定义就可以阻止成员函数和友元。

### 拷贝控制和资源管理
定义拷贝操作，使类的行为看起来像一个值或像一个指针。类的行为像一个值，意味着它应该有自己的状态。我们拷贝一个像值的对象时，副本和源对象是完全独立的。行为像指针的类则共享状态。当我们拷贝要个这种类的对象时，副本和原对象使用相同的底层数据。改变副本也会改变原对象，反之亦然。在我们使用过的标准库类中，标准库容器和string类的行为像一个值。shared_ptr类提供类似指针的行为。IO类和unique_ptr不允许拷贝或赋值，它们的行为既不像值也不像指针。

#### 行为像值的类
为了提供类值的行为，对于类管理的资源，每个对象都应该拥有一份自己的拷贝。为了实现类值行为，HasPtr需要
- 定义一个拷贝构造函数，完成string的拷贝，而不是拷贝指针
- 定义一个析构函数来释放string
- 定义一个拷贝赋值运算符来释放对象当前的string,并从右侧运算对象拷贝string

类值版本的HasPtr 如下:
```C++
class HasPtr{
    public:
        HasPtr(const std::string &s = std::string()):
            ps(new std::string(s)), i(0) {}
        HasPtr(const HasPtr &p):
            ps(new std::string(*p.ps)), i(p.i) {}
        HasPtr &operator=(const HasPtr &);
        ~HasPtr() {delete ps;}
    private:
        std::string ps;
        int i;
};
```

##### 类值拷贝赋值运算符
赋值运算符通常组合了析构函数和构造函数的操作。类似析构函数，赋值操作会销毁左侧运算对象的资源。类似拷贝构造函数，赋值操作会从右侧运算对象拷贝数据。这些操作是以正确的顺序执行的，即使将一个对象赋予它自身，也保证准确。而且，如果可能，我们编写的赋值运算符还应该是异常安全的----当异常发生时能将左侧运算对象置于一个有意义的状态。<br>
在本例中，通过先拷贝右侧运算对象，我们可以处理自赋值情况，并能保证在异常发生时代码也是安全的。在完成靠别后我们释放左侧运算对象的资源，并更新指针指向新分配的string：
```C++
HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    auto newp = nes string(*rhs.ps);
    delete ps;
    ps = newp;
    i = rhs.i;
    return *this;
}
```
[代码实现](./HasPtr/src/hasPtr_val.cpp)

**关键概念:赋值运算符**<br>
编写赋值运算符时，有两点需要记住:
- 如果将一个对象赋予它自身，赋值运算符必须能正确工作
- 大多数赋值运算组合了析构函数和拷贝构造函数的工作

编写一个赋值运算符时，一个好的模式时先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，销毁左侧运算对象的先哟成员就是安全的了。一旦左侧运算对象资源被销毁，就只剩下将数据从临时对象拷贝到左侧运算对象的成员了。

#### 定义行为像指针的类
对于行为类似指针的类，我们需要为其定义拷贝构造函数和拷贝赋值运算符，来拷贝指针成员本身而不是它指向的string。我们的类任然需要自己的析构函数来释放接受string参数的构造函数分配的内存。但在，在本例中，析构函数不能单方面的释放关联的string。只有当最后一个指向string的HasPtr销毁时，它才可以释放string。<br>
我们直接管理资源，使用引用计数就很有用了。为了说明引用计数如何工作，我们将重新定义HasPtr,令其行为像指针一样，但我们不使用shared_ptr，设计自己的引用计数

##### 引用计数
引用计数工作方式如下:
- 除了初始化对象外，每个构造函数(拷贝构造函数除外)还要创建一个引用计数，用来记录有多少对象正在创建的对象共享状态。当我们创建一个对象时，只有一个对象共享状态
- 拷贝构造函数不分配新的计数器，而是拷贝给定对象的数据成员，包括计数器。拷贝构造函数递增共享计数器，指出给定对象的状态又被一个新用户所共享
- 析构函数递减计数器，指出共享状态的用户少了一个。如果计数器变为0，则析构函数释放状态
- 拷贝赋值运算符递增右侧运算对象的计数器，递减左侧运算对象的计数器。如果左侧运算对象的计数器变为0，意味着它的共享状态没有用户了，拷贝赋值运算符就必须销毁状态。

共享计数器的一种方法是将计数器保存在动态内存中。创建一个对象时，我们分配一个新的计数器。当拷贝或赋值对象时，我们拷贝指向计数器的指针。使用这种方法，副本和原对象都会指向相同的计数器。

##### 定义一个使用引用计数的类
编写类指针的HasPtr版本:
```C++
class HasPtr{
    public:
        HasPtr(const std::string &s=std::string()):ps(new std::string(s)),i(0),use_count(new std::size_t(1)) {}
        HasPtr(const HasPtr &p):ps(p.ps),i(p.i), use_count(p.use_count) {++*use_count;}
        HasPtr &operator=(const HasPtr &);
        ~HasPtr();
    private:
    std::string *ps;
    int i;
    std::size_t *use_count;
};
```
当拷贝或赋值一个HasPtr对象时，我们希望副本和原对象都指向相同的string。即，拷贝一个HasPtr时，我们将拷贝ps本身，而不是ps指向的string。当我们进行拷贝时，还会递增该string关联的计数器。<br>
析构函数不能无条件地delete ps ----可能亥哟其他对象指向这块内存。析构函数应该递减引用计数，指出共享string地对象少了一个。如果计数为0，则析构函数释放ps和use_count指向地内存:
```C++
HasPtr::~HasPtr()
{
    if (--*use_count == 0)
    {
        delete ps;
        delete use;
    }
}
```
拷贝赋值运算符与往常一样执行类似拷贝构造函数和析构函数的工作。即，它必须递增右侧运算符对象的引用计数，并递减左侧运算对象的引用计数，在必要时释放使用的内存。赋值运算符必须处理自赋值。
```C++
HasPtr &HasPtr::operator=(const HasPtr &rhs)
{
    ++*rhs.use;
    if (--*use_count == 0)
    {
        delete ps;
        delete use_count;
    }
    ps = rhs.ps;
    i = rhs.i;
    use_count = rhs.use_count;
    return *this;
}
```
[代码实现](./HasPtr/src/hasPtr_ptr.cpp)

#### 交换操作
如果一个类定义了自己的swap，那么算法将使用类自定义版本。否则算法将使用标准库定义的swap。swap实现是为了交换两个对象，我们需要进行一次拷贝和两次赋值。交换两个类值HasPtr对象：
```C++
HasPtr temp = v1;
v1 = v2;
v2 = temp;
```
这段代码将V1的string拷贝了两次 ---- 第一次是HasPtr的拷贝构造函数将v1拷贝给temp,第二次是赋值运算符将temp赋予v2。将v2赋予v1的语句还拷贝了原来v2中的string。理论上，这些内存分配都不是必要的。我们更希望swap交换指针，而不是分配string的副本。即:
```C++
string *temp = v1.ps;
v1.ps = v2.ps;
v2.ps = temp;
```

##### 编写我们自己的swap函数
可以在我们的类上定义一个自己版本的swap重载swap的默认行为。swap的典型实现如下:
```C++
class HasPtr{
    friend void swap(HasPtr &, HasPtr &);

};

inline void swap(HasPtr &lhs, HasPtr &rhs)
{
    using std::swap;
    swap(lhs.ps, rhs.ps);
    swap(lhs.i, rhs.i);
}
```

##### 在赋值运算符中使用swap
定义swap的类通常用swap来定义它们的赋值运算符。这些运算符使用了一种名为拷贝并交换的技术。这种技术将左侧运算对象与右侧运算对象的一个副本交换：
```C++
HasPtr &HasPtr::operator=(HasPtr rhs)
{
    swap(*this, rhs);
    return *this;
}
```
我们将右侧运算对象以传值方式传递给了赋值运算符。因此，rhs是右侧运算对象的一个副本。参数传递时拷贝HasPtr操作会分配该对象的string的一个新副本。<br>
在赋值运算符的函数体中，我们调用swap交换rhs和\*this中的数据成员。这个调用将左侧运算对象原来保存的指针存入this中，并将rhs中原来的指针存入\*this。因此，在swap调用之后， *this中的指针成员将指向新分配的string ---- 右侧运算对象中string的一个副本。<br>
当赋值运算符结束时，rhs被销毁，HasPtr的析构函数将执行。此析构函数delete rhs现在指向的内存，即，释放掉左侧运算对象中原来的内存。<br>
这个技术的有趣之处是它自动处理了自赋值情况是异常安全的。通过改变左侧运算对象之前拷贝右侧运算对象保证了自赋值的正确，这与我们在原来的赋值运算符中使用的方法是一致的。

### 拷贝控制实例
[代码实现](./Msg_Folder/src/message.h)

### 动态内存管理类
[代码实现](./StrVec/src/strVec.h)

### 对象移动
C++11新标准一个最主要特性是可以移动而非拷贝对象的能力。在某些情况下，对象拷贝后就立即被销毁了。在这些情况下，移动而非拷贝对象会大幅度提升性能。在重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。使用移动而不是拷贝的另一个原因是IO类后unique_ptr这样的类。这些类都包含不能被共享的资源(如指针或IO缓冲)。因此，这些类型的对象不能拷贝但可以移动

#### 右值引用
为了支持移动操作，新标准引入了一种新的引用类型 ---- **右值引用**。我们通过&&而不是&来获得右值引用。右值引用有一个重要的性质 ----只能绑定到一个将要销毁的对象。因此，我们可以自由的将一个右值引用的资源“移动”到另一个对象中。我们将右值引用绑定到要求转化的表达式、字面常量或返回右值的表达式，但不能将一个右值引用直接绑定到一个左值上:
```C++
int i = 42;
int &r = i;                 //正确: r引用i
int &&rr = i;               //错误：不能将一个右值引用绑定到一个左值上
int &r2 = i * 42;           //错误: i * 42 不是一个左值
const int &r3 = i * 42;     //正确: 我们可以将一个const的引用绑定到一个右值上
int &&rr2 = i * 42;         //正确: 将rr2绑定到 i * 42的结果上
```
返回左值引用，连同赋值、下标、解引用和前置递增/递减运算符，都是返回左值的表达式的例子。<br>
连同算术、关系、位以及后置递增/递减运算符，都生成右值。我们不能将左值引用绑定到这类表达式上，我们可以将一个const的左值引用或右值引用绑定到这类表达式上。

左值有持久的状态，而右值要么是字面常量，要么是表达式求值过程中创建的临时变量：
- 所引用的对象将要被销毁
- 该对象没有其他用户

这两个特性意味着：使用右值引用的代码可以自由的接管所引用的对象的资源。

##### 变量是左值
变量可以看作只有一个运算对象而没有运算符的表达式。类似其他任何表达式，变量表达式也有左值/右值属性。变量表达式都是左值--->我们不能将一个右值引用绑定到一个右值引用类型的变量上：
```C++
int &&rr1 = 42;     // 正确：字面常量是右值
int &&rr2 = rr1;    // 错误：rr1是左值
```
- 变量是左值，因此我们不能将一个右值直接绑定到一个变量上，即使这个变量是右值引用也不行

##### 标准库move函数
虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应地右值引用类型--->通过调用一个**move**的新标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件utility中。
```C++
int &&rr3 = std::move(rr1); // 正确
```
调用move就意味着：除了对rr1赋值或销毁它外，我们将不再使用它。在调用move之后，我们不能对移后源对象的值做任何假设。

#### 移动构造函数和移动赋值运算符
类似拷贝构造函数，移动构造函数第一个参数是该类类型的一个引用。不同拷贝构造函数，这个引用参数在移动构造函数中是一个右值引用。与拷贝构造函数一样，任何额外的参数都必须有默认实参。除了完成资源移动，移动构造函数还必须确保以后源处于销毁状态。一旦资源完成移动，源对象必须不再指向被移动的资源----这些资源的所有权已经归属新创建的对象。<br>
作为一个例子，我们为StrVec类定义移动构造函数，实现从一个StrVec到另一个StrVec的元素移动而非拷贝:
```C++

```