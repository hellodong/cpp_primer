## Control Copy

[TOC]

定义一个类时，我们显示或者隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

### 拷贝、赋值与销毁
我们将以最基本的操作----拷贝构造函数、拷贝赋值运算符和析构函数作为开始。然后介绍移动操作(新标准所引入的操作)。

#### 拷贝构造函数
如果一个构造函数第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
```C++
class Foo{
    public:
        Foo();              // 默认构造函数
        Foo(const Foo&);    // 拷贝构造函数
};
```
拷贝构造函数的第一个参数必须是一个引用类型。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常不应该是explicit。

##### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。<br>
对于某些类来说,**合成拷贝构造函数**用来阻止我们拷贝该类类型的对象。一般情况,合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

##### 拷贝初始化
```C++
string dots(10,'.');        // 直接初始化
string s(dots);             // 直接初始化
string s2 = dots;           // 拷贝初始化
string null_book = "9-999-99999-9"; //拷贝初始化
string nines = string(100,'9');     //拷贝初始化
```
我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。<br>
拷贝初始化通常使用拷贝构造函数来完成。但是如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。现在，拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。<br>
拷贝初始化不仅在我们用=定义变量时会发生，下列情况也会发生:
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。例如,初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。

##### 参数和返回值
在函数调用过程中，其有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。


