## Control Copy

[TOC]

定义一个类时，我们显示或者隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么：拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符和析构函数。如果一个类没有定义所有这些拷贝控制成员，编译器会自动为它定义缺失的操作。

### 拷贝、赋值与销毁
我们将以最基本的操作----拷贝构造函数、拷贝赋值运算符和析构函数作为开始。然后介绍移动操作(新标准所引入的操作)。

#### 拷贝构造函数
如果一个构造函数第一个参数时自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。
```C++
class Foo{
    public:
        Foo();              // 默认构造函数
        Foo(const Foo&);    // 拷贝构造函数
};
```
拷贝构造函数的第一个参数必须是一个引用类型。虽然我们可以定义一个接受非const引用的拷贝构造函数，但此参数几乎总是一个const的引用。拷贝构造函数在几种情况下都会被隐式地使用，因此拷贝构造函数通常不应该是explicit。

##### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同，即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。<br>
对于某些类来说,**合成拷贝构造函数**用来阻止我们拷贝该类类型的对象。一般情况,合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定对象中依次将每个非static成员拷贝到正在创建的对象中。

##### 拷贝初始化
```C++
string dots(10,'.');        // 直接初始化
string s(dots);             // 直接初始化
string s2 = dots;           // 拷贝初始化
string null_book = "9-999-99999-9"; //拷贝初始化
string nines = string(100,'9');     //拷贝初始化
```
我们使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话还要进行类型转换。<br>
拷贝初始化通常使用拷贝构造函数来完成。但是如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。现在，拷贝初始化是依靠拷贝构造函数或移动构造函数来完成的就可以了。<br>
拷贝初始化不仅在我们用=定义变量时会发生，下列情况也会发生:
- 将一个对象作为实参传递给一个非引用类型的形参
- 从一个返回类型为非引用类型的函数返回一个对象
- 用花括号列表初始化一个数组中的元素或一个聚合类中的成员

某些类类型还会对他们所分配的对象使用拷贝初始化。例如,初始化标准库容器或调用其insert或push成员时，容器会对其元素进行拷贝初始化。与之相对，用emplace成员创建的元素都进行直接初始化。

##### 参数和返回值
在函数调用过程中，其有非引用类型的参数要进行拷贝初始化。类似的，当一个函数具有非引用的返回类型时，返回值会被用来初始化调用方的结果。

#### 拷贝赋值运算符
与拷贝构造函数一样，如果类未定义自己的拷贝赋值运算符，编译器会为它合成一个。

##### 重载赋值运算符
重载运算符本质上函数，其名字由operator关键字后接表示要定义的运算符的符号组成。赋值运算符：operator=。其由返回类型和一个参数列表。<br>
拷贝赋值运算符接受一个与其苏哦在类相同类型的参数:
```C++
class Foo{
    public:
    Foo &operator=(const Foo&);
};
```
赋值运算符通常返回一个指向其左侧运算对象的引用。另外，标准库通常要求保存在容器中的类型要具有运算符，其返回值是左侧运算对象的引用。

##### 合成拷贝赋值运算符
与拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个**合成拷贝赋值运算符**。对于某些类，合成拷贝构造函数运算符用来禁止该类型对象的赋值。如果并非出于此目的，它会将右侧运算对象的每个非static成员赋予左侧运算对象的对应成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。

#### 析构函数
析构函数执行与构造函数相反的操作:构造函数初始化对象的非static成员；析构函数释放对象使用的资源，并销毁对象的非static数据成员。<br>
析构函数是类的一个成员函数，名字由波浪号接类名组成。它没有返回值，也不接受参数:
```C++
class Foo{
    public:
        ~Foo();
};
```
对于一个给定类，只有一个析构函数。
##### 析构函数完成什么工作
在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化的逆序销毁。在对象最后一次使用之后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。<br>
析构部分是隐式的。成员销毁时发生什么完全依赖于成员的类型。销毁类类型的成员需要执行成员自己的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。<br>
无论何时一个对象被销毁，就会自动调用其析构函数：
- 变量在离开其作用域时被销毁
- 当一个对象被销毁时，其成员被销毁
- 容器(标准库容器或者数组)被销毁时，其元素也被销毁
- 动态分配的对象，当对指向它的指针应用delete运算符时被销毁
- 临时对象，创建它的完整表达式结束时被销毁

##### 合成析构函数
当一个类未定义自己的析构函数时，编译器会为它定义一个**合成析构函数**。类似拷贝构造函数和拷贝赋值运算符，对于某些类，合成析构函数被用来阻止该类型对象被销毁。如果不是这种情况，合成析构函数的函数体就为空。<br>
下面的代码片段等价于Sales_data的合成析构函数:
```C++
class Sales_data{
    public:
        ~Sales_data(){}
};
```
在(空)析构函数体执行完毕后，成员会被自动销毁。特别的，string的析构函数会被调用，它将释放bookNo成员所用的内存。析构函数体自身并不直接销毁成员。成员是在析构函数体之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分进行的。

#### 三五法则
如前所述，有三个基本可以控制类的拷贝操作:拷贝构造函数、拷贝赋值运算符和析构函数。而且，在C++11标准下，一个类还可以定义一个移动构造函数和一个移动赋值运算符。<br>
C++语言并不要求我们定义所有这些操作:可以只定义其中一个 或两个，而不必定义所有。但是这些操作通常应该被看做一个整体。通常，只需要其中一个操作，而不需要定义所有操作的情况是少见的。

##### 需要析构函数的类也需要拷贝和赋值操作
当我们决定一个类是否要定义它自己版本的拷贝控制成员时，一个基本原则是首先确定这个类是否需要一个**析构函数**。如果这个类需要析构函数，我们几乎可以肯定它也需要一个拷贝构造函数和一个拷贝赋值运算符。<br>
用HasPtr类作为例子，这个类在构造函数中分配动态内存。合成析构函数不会delete一个指针数据成员。因此，此类需要定义一个析构函数来释放构造函数分配的内存。
```C++
class HasPtr{
    public:
        HasPtr(const std::string &s=std::string()):ps(new std::string(s)), i(0) {}
        ~HasPtr(){
            delete ps;
        }
};
```
构造函数中分配的内存将在HasPtr对象销毁时被释放。但是，我们引入了个严重的错误！这个版本的类使用了合成的拷贝构造函数和拷贝赋值运算符。这些函数简单拷贝指针成员，意味着多个HasPtr对象可能指向相同的内存：
```C++
HasPtr f(HasPtr hp)     //传值参数，所以被拷贝
{
    HasPtr ret = hp;    // 拷贝给定的HasPtr
    /* process hp */
    return ret;         // ret和hp被销毁
}
```
当f返回时，hp和ret都被销毁，在两个对象上都会调用HasPtr的析构函数。此析构函数会delete ret和hp的指针成员。此代码会导致此指针被delete两次，这显然是一个错误。

##### 需要拷贝操作的类也需要赋值操作，反之亦然
某些类所要完成的工作，只需要拷贝或赋值操作，不需要析构函数。如果一个类需要拷贝构造函数，几乎可以肯定它也需要一个拷贝赋值运算符。反之亦然。然而，无论是否需要拷贝构造函数还是拷贝赋值运算符都不必然以为着也需要析构函数。


