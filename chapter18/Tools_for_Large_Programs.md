## Tools for Large Programs
本章价绍三种C++语言特性：异常处理、命名空间和多重继承

### 异常处理
异常处理（**exception handling**)机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并作出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。

#### 抛出异常
在C++语言中，我们抛出(throwing)一条表达式引发(raised)一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码(handler)将被用来处理该异常。<br>
当执行一个throw时，跟在throw后面的语句将不再执行。相反，程序的控制权从throw转移到了与之匹配的catch模块。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个含义:
- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁

跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似return。

##### 栈展开
当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出现在**try语句块**(**try block**)内时，检查与该try块关联的catch子句。找到匹配的catch，就使用该catch处理异常。如果没找到匹配的catch，且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找。<br>
如果对抛出异常的函数的调用语句位于try语句块内，则检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。否则，如果该try语句嵌套在其他try块中，继续检查与外层try匹配的catch子句。如果仍然没找到匹配的catch，就退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。<br>
上诉过程称为**栈展开**(**stack unwinding**)过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也有可能一直没找到匹配的catch,则退出主函数后查找过程终止。<br>
假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。<br>
如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件。当找不到匹配的catch时，程序将调用标准库函数**terminate**， 顾名思义，terminate负责终止程序的执行过程。

- 一个异常如果没有被捕获，则它将终止当前的程序

##### 栈展开过程中对象被自动销毁
在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。<br>
异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还没有初始化。如果异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。

##### 析构函数与异常
析构函数不应该抛出不能被自身处理的异常。如果需要析构函数执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块中，并且析构函数内部得到处理。<br>
在实际的编程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。

- 一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。

##### 异常对象
**异常对象** (exception object)是一种特殊的对象，编译器是用异常抛出表达式来对异常对象进行拷贝初始化。因此, throw语句中的表达式必须拥有完全类型。


