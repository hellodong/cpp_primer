## Tools for Large Programs
本章价绍三种C++语言特性：异常处理、命名空间和多重继承

### 异常处理
异常处理（**exception handling**)机制允许程序中独立开发的部分能够在运行时就出现的问题进行通信并作出相应的处理。异常使得我们能够将问题的检测与解决过程分离开来。程序的一部分负责检测问题的出现，然后解决该问题的任务传递给程序的另一部分。

#### 抛出异常
在C++语言中，我们抛出(throwing)一条表达式引发(raised)一个异常。被抛出的表达式的类型以及当前的调用链共同决定了哪段处理代码(handler)将被用来处理该异常。<br>
当执行一个throw时，跟在throw后面的语句将不再执行。相反，程序的控制权从throw转移到了与之匹配的catch模块。该catch可能是同一个函数中的局部catch，也可能位于直接或间接调用了发生异常的函数的另一个函数中。控制权从一处转移到另一处，这有两个含义:
- 沿着调用链的函数可能会提早退出
- 一旦程序开始执行异常处理代码，则沿着调用链创建的对象将被销毁

跟在throw后面的语句将不再被执行，所以throw语句的用法有点类似return。

##### 栈展开
当抛出一个异常后，程序暂停当前函数的执行过程并立即开始寻找与异常匹配的catch子句。当throw出现在**try语句块**(**try block**)内时，检查与该try块关联的catch子句。找到匹配的catch，就使用该catch处理异常。如果没找到匹配的catch，且该try语句嵌套在其他try块中，则继续检查与外层try匹配的catch子句。如果还是找不到匹配的catch，则退出当前的函数，在调用当前函数的外层函数中继续寻找。<br>
如果对抛出异常的函数的调用语句位于try语句块内，则检查与该try块关联的catch子句。如果找到了匹配的catch，就使用该catch处理异常。否则，如果该try语句嵌套在其他try块中，继续检查与外层try匹配的catch子句。如果仍然没找到匹配的catch，就退出当前这个主调函数，继续在调用了刚刚退出的这个函数的其他函数中寻找，以此类推。<br>
上诉过程称为**栈展开**(**stack unwinding**)过程。栈展开过程沿着嵌套函数的调用链不断查找，直到找到了与异常匹配的catch子句为止；或者也有可能一直没找到匹配的catch,则退出主函数后查找过程终止。<br>
假设找到了一个匹配的catch子句，则程序进入该子句并执行其中的代码。当执行完这个catch子句后，找到与try块关联的最后一个catch子句之后的点，并从这里继续执行。<br>
如果没找到匹配的catch子句，程序将退出。因为异常通常被认为是妨碍程序正常执行的事件。当找不到匹配的catch时，程序将调用标准库函数**terminate**， 顾名思义，terminate负责终止程序的执行过程。

- 一个异常如果没有被捕获，则它将终止当前的程序

##### 栈展开过程中对象被自动销毁
在栈展开过程中，位于调用链上的语句块可能会提前退出。通常情况下，程序在这些块中创建了一些局部对象。我们已经知道，块退出后它的局部对象也将随之销毁，这条规则对于栈展开过程同样适用。如果某个局部对象的类型是类类型，则该对象的析构函数将被自动调用。<br>
异常发生在构造函数中，则当前的对象可能只构造了一部分。有的成员已经初始化了，而另外一些成员在异常发生前也许还没有初始化。如果异常发生前已经构造了一部分元素，则我们应该确保这部分元素被正确地销毁。

##### 析构函数与异常
析构函数不应该抛出不能被自身处理的异常。如果需要析构函数执行某个可能抛出异常的操作，则该操作应该被放置在一个try语句块中，并且析构函数内部得到处理。<br>
在实际的编程中，因为析构函数仅仅是释放资源，所以它不太可能抛出异常。所有标准库类型都能确保它们的析构函数不会引发异常。

- 一旦在栈展开的过程中析构函数抛出了异常，并且析构函数自身没能捕获到该异常，则程序将被终止。

##### 异常对象
**异常对象** (exception object)是一种特殊的对象，编译器是用异常抛出表达式来对异常对象进行拷贝初始化。因此, throw语句中的表达式必须拥有完全类型。

#### 捕获异常
**catch**子句中的异常声明看起来像是只包含一个形参的函数形参列表。声明的类型决定了处理代码所能捕获的异常类型。这个类型必须是完全类型，它可以是左值引用，但不能右值引用。

##### 查找匹配的处理代码
在搜寻catch语句的过程中，我们最终找到catch未必是异常的最佳匹配。相反，挑选出来的应该是第一个与异常匹配的catch语句。因此，越是专门的catch越应该置于整个catch列表的前端。<br>
catch 语句是按照其出现的顺序逐一进行匹配，所以当程序使用具有继承关系的多个异常时必须对catch语句的顺序进行组织和管理，使得派生类异常的处理代码出现在基类处理代码之前。<br>
与实参和形参的匹配规则相比，异常和catch异常声明的匹配规则受到更多限制。此时，绝大多数类型转换都不被允许，除了一些及细小的差别之外，要求异常的类型和catch声明的类型是精确匹配的:
- 允许非常量向常量的类型转换
- 允许派生类向基类的转换
- 数组被转换成指向数组类型的指针，函数被转换成指向该函数类型的指针。

除此之外，包括标准算术类型转换和类类型转换在内，其他所有转换规则都不能匹配catch的过程中使用。

##### 重新抛出
有时，一个单独的catch语句不能完整处理某个异常。在执行了某些校正操作后，当前的catch可能会决定由调用链更上一层的函数接着处理异常。一条catch语句通过重新抛出(rethrowing),将异常传递给另外一个catch语句。这里的重新抛出仍然是一条throw语句，只不过不包含任何表达式:
```C++
throw;
```
空的throw语句只能出现在catch语句或catch语句直接或间接调用的函数之内。如果在处理代码之外的区域遇到了空throw语句，编译器将调用terminate。<br>
一个重新抛出语句并不指定新的表达式，而是将当前的异常对象沿着调用链向上传递。<br>
很多时候，catch语句会改变其参数的内容。如果在改变了参数的内容后catch语句重新抛出异常，则只有当catch异常声明是引用类型时我们对参数所作的改变才会被保留并继续传播:
```C++
catch (my_error &eObj)                      // 引用类型
{
    eObj.status = errCodes::servereErr;     // 修改了异常对象 
    throw;                                  // 异常对象的status成员是severeErr
}
catch (other_error eObj)                    // 非引用类型
{
    eObj.status = errCodes::badErr;
    throw;   // 异常对象的status 成员没改变
}
```

##### 捕获所有异常的处理代码
为了一次性捕获所有异常，我们使用省略号为异常声明，这样的处理代码称为捕获所有异常(catch-all)的处理代码，形如catch(...)。一条捕获所有异常的语句可以与任意类型的异常匹配。<br>
catch(...)通常与重新抛出语句一起使用，其中catch执行当前局部能完成的工作，随后重新抛出异常:
```C++
void main(int argc, char *argv[])
{
    try{
        // 这里的操作将引发并抛出一个异常
    }catch (...) {
        // 处理异常的某些特殊操作
        throw;
    }
}
```
catch(...)既能单独出现，也能与其他几个catch语句一起出现。

##### 函数try语句块与构造函数
通常情况下，程序执行的任何时刻都可能发生异常，特别是异常可能发生在处理构造函数初始值的过程中。构造函数在进入其函数体之前首先执行初始值列表。因为在初始值列表抛出异常时构造函数体内的try语句块还未生效，所以构造函数体内的catch语句无法处理构造函数初始值列表抛出的异常。<br>
要想处理构造函数初始值抛出的异常，我们必须将构造函数写成**函数try语句块**的形式。函数try语句块使得一组catch语句既能处理构造函数体，也能处理构造函数的初始化过程。举个例子，我们可以把Blob的构造函数置于一个函数try语句块中:
```C++
template <tepename T>
Blob<T>::Blob(std::initializer_list<T> il) try : data(std::make_shared<std::vector<T>>)
{
    //空函数体
} 
catch(const std::bad_alloc &e) {
    handle_out_of_memory(e);
}
```
与这个try关联的catch既能处理构造函数体抛出的异常，也能处理成员初始化列表抛出的异常。<br>
还有一种情况值得注意，在初始化构造函数的参数时也有可能发生异常，这样的异常不属于函数try语句块的一部分。和其他函数调用一样，如果参数初始化过程中发生了异常，则该异常属于调用表达式的一部分，并将再调用者所在的上下文中处理。